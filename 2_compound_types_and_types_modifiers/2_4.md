# Функции и указатели на функции Functions and pointers to functions.
***
### Перегрузки - Overloads
> #### А умножить на Б
>* переменожить как числа, если А и Б - числа
>* переменожить как матрицы, если А и Б - матрицы
>* перемножить векторно, если А и Б - веторы
>* перемножить как вектор и скаляр, если это вектор и скаляр
>* и так далее, и так далее, и так далее
```c++
int f(float) {
    return 1;
}

double f(int) {
    return 2;
}

int main() {
    int a = f(0.5);
}
```
> Правила выбора перегрузки (которые стоит помнить)
> * promotion (float to double, int to long long) лучше чем конверсия
> * стандартная конверсия (из int в float), лучше чем пользовательская

### Аргументы функций
```c++
void f(double);
void f(int);
void f(...);
void f(int, ...);
void f(int x, double d = 0,5); // значения по умолчанию после обычных
void f(int x)
```
### Указатели на функцию
```c++
int main() {
    void(*p)(int) = &f;
    void(*p)(double) = &f;
    p(5); // likely segfault
    p += 10; // UB (сдвинули указатель)
    std::cout << p; // 1
    std::cout << (void(*)(int))(ptr) // - каст обычного указателя к указателю на функцию
}
```
##### Зачем нужны указатели на фукции?  
Чтобы была возможность передавать функции как аргументы других функций. Например, как в ```std::sort(a, a + 10, &cmp)```

### Inline

Некоторые функции можно объявить ``inline``  
```c++
inline int foo(int x) {
    return x;
}
```
#### Зачем нужен inline?
При вызове функции процессор должен записать точку возврата + переключиться на код функции (который лежит где-то в другом месте), ``inline`` встраивает код функции прямо в код  
> Современные компиляторы сами оптимизируют inline (игнорируют где считают, что он не нужен, добавляют, где нужен)